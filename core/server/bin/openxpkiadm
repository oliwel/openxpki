#!/usr/bin/perl

use strict;
use warnings;
use English;
use OpenXPKI::Debug;
use OpenXPKI::Control;
use Getopt::Long;
use Pod::Usage;
use POSIX ":sys_wait_h";
use Errno;
use File::Spec;
use Proc::ProcessTable;

# For the password hasher
use IO::Prompt;
use Digest::SHA;
use Digest::MD5;
use Proc::SafeExec;
use MIME::Base64;

use OpenXPKI::Server::Init;
use OpenXPKI::Server::Context qw( CTX );

use OpenXPKI::VERSION;

use Data::Dumper;

my %params;
my @options_spec = ('config=s');
my $cmd = shift || 'help';
my $ret = 255;

sub initdb {

    my @databases = qw( backend );

    # Check if a seperate logging database is defined

    if (CTX('config')->exists('system.database.logging')) {
        push @databases, 'log';
    }

  DB:
    foreach my $db (@databases) {
        my $params = {};
        $params->{PURPOSE} = $db;

        if ( defined $params->{PURPOSE} ) {
            print STDERR "Setting up database '$db'\n";
        }
        my $dbi = OpenXPKI::Server::Init::get_dbi($params);

        eval { $dbi->connect() };
        if ($EVAL_ERROR) {
            print STDERR
              "ERROR: Could not connect to '$db' database ($EVAL_ERROR)\n";
            return 2;
        }

        if ( $params{'dry-run'} ) {
            print $dbi->init_schema( MODE => 'DRYRUN' ) . "\n";
            last DB;
        }
        else {
            my %args = ();
            if ( $params{force} ) {
                $args{MODE} = 'FORCE';
            }

            #### args for init_schema : Dumper(\%args)
            eval { $dbi->init_schema(%args); };
            if ($EVAL_ERROR) {
                print STDERR
                  "ERROR: init_schema on '$db' failed (${EVAL_ERROR})\n";
                return 2;
            }
            print STDERR "Database '$db' initialized.\n";
        }
    }
    return 0;
}


sub loadcfg {

    if ($params{path}) {
        # we set the ENV as this
        # a) can split a string
        # b) otherwise an external set ENV will override the parameter
        $ENV{OPENXPKI_CONF_PATH} = $params{path};
    }

    require OpenXPKI::Config::Merge;
    my $config = OpenXPKI::Config::Merge->new();
    printf "Current Tree Version: %s\n", $config->version();

    if ($params{reload}) {
        OpenXPKI::Control::reload();
    }
    return;

}


sub certificate_id {

    my $format = $params{format} || 'openxpki';

    my $filename = $params{file};

    if ( !-r $filename ) {
        print STDERR "ERROR: filename '$filename' is not readable\n";
        return 2;
    }

    if ($format eq 'openssl') {
        my @exec = ('openssl','x509','-noout','-hash','-inform','PEM','-in', $filename);
        my ($id, undef) = Proc::SafeExec::backtick(@exec);
        chomp $id;
        print "$id\n";
        return 0;
    } elsif ($format ne 'openxpki') {
        print STDERR "Invalid format - supported formats are openssl|openxpki\n";
        return 1;
    }

    my $defaulttoken = CTX('crypto_layer')->get_system_token({TYPE => 'DEFAULT'});

    if ( !defined $defaulttoken ) {
        print STDERR "ERROR: Could not get default token\n";
        return 2;
    }

    my $FileUtils = OpenXPKI::FileUtils->new();
    my $certdata  = $FileUtils->read_file($filename);

    if ( !defined $certdata ) {
        print STDERR "ERROR: Could not parse certificate data\n";
        return 2;
    }

    my ($extracted_certdata) = $certdata =~ m{ \A .* (-----BEGIN\ CERTIFICATE----- .* -----END\ CERTIFICATE-----) .* \z}xms;

    my $cert = OpenXPKI::Crypto::X509->new(
        TOKEN => $defaulttoken,
        DATA  => $extracted_certdata,
    );

    print $cert->get_identifier();
    print "\n";

    return 0;

 }

sub certificate_import {

    print STDERR "Starting import\n";

    my $defaulttoken = CTX('crypto_layer')->get_system_token({TYPE => 'DEFAULT'});

    if ( !defined $defaulttoken ) {
        print STDERR "ERROR: Could not get default token\n";
        return 2;
    }

    my $dbi = __get_dbi();

    my $filename = $params{file};

    if ( !-r $filename ) {
        print STDERR "ERROR: filename '$filename' is not readable\n";
        return 2;
    }

    my $FileUtils = OpenXPKI::FileUtils->new();
    my $certdata  = $FileUtils->read_file($filename);

    if ( !defined $certdata ) {
        print STDERR "ERROR: Could not parse certificate data\n";
        return 2;
    }

    if (   ( !defined $params{issuer} || $params{issuer} eq '' )
        && ( defined $params{realm} ) )
    {
        print STDERR "ERROR: You have to specify an issuer (or leave "
          . "out --realm for self-signed certificates).\n";
        return 1;
    }

    my ($extracted_certdata) = $certdata =~ m{ \A .* (-----BEGIN\ CERTIFICATE----- .* -----END\ CERTIFICATE-----) .* \z}xms;

    my $cert = OpenXPKI::Crypto::X509->new(
        TOKEN => $defaulttoken,
        DATA  => $extracted_certdata,
    );
    #### cert : Dumper($cert)

    my $realm;
    my $issuer_identifier;
    if ( !defined $params{realm} || $params{realm} eq '' ) {

        # user wants to import a self-signed
        # cert, let's check if it really is one
        ### subject key id : $cert->get_subject_key_id()
        ### authority key id : $cert->get_authority_key_id()
        if (
               defined $cert->get_subject_key_id()
            && defined $cert->get_authority_key_id()
            && ref $cert->get_authority_key_id() eq '' # TODO: check if hash
            && (
                $cert->get_subject_key_id() ne $cert->get_authority_key_id()
            )
          )
        {
            if ( !defined $params{'force-really-self-signed'} ) {
                print STDERR "ERROR: This is not a self-signed "
                  . "certificate, "
                  . "(subject key id and authority key id do not match) "
                  . "please specify --realm if you want to import a "
                  . "normal certificate.\n";
                return 2;
            }
        }
        if ( $cert->{PARSED}->{BODY}->{SUBJECT} ne
            $cert->{PARSED}->{BODY}->{ISSUER} )
        {
            if ( !defined $params{'force-really-self-signed'} ) {
                print STDERR "ERROR: This is not a self-signed "
                  . "certificate, "
                  . "(subject and issuer do not match) "
                  . "please specify --realm if you want to import a "
                  . "normal certificate.\n";
                return 2;
            }
        }

        # we are our own issuer
        $issuer_identifier = $cert->get_identifier();
    }
    else {    # we have a "normal" certificate
        if ( defined $params{'issuer-realm'} ) {
            $realm = $params{'issuer-realm'};
        }
        else {
            $realm = $params{realm};
        }

        # maybe the issuer name is an alias, try to resolve it
        $issuer_identifier = __resolve_alias(
            {
                DBI   => $dbi,
                NAME  => $params{issuer},
                REALM => $realm,
            }
        );
        ### issuer_identifier : $issuer_identifier
        # check whether the certificate is in the DB
        my $issuer = $dbi->first(
            TABLE   => 'CERTIFICATE',
            DYNAMIC => { IDENTIFIER => $issuer_identifier, },
        );
        if (   !defined $issuer
            && !defined $params{'force-issuer-not-found'} )
        {
            print STDERR "ERROR: Issuer '$params{issuer}' not found in "
              . "the database.\n";
            return 2;
        }
    }

    # make sure the self-signed realm is specified as 'undef'
    if ( defined $realm && ( $realm eq '' ) ) {
        $realm = undef;
    }

    # compile all relevant data for the database
    # TODO: use $cert->to_db_hash();
    my %insert_hash;
    $insert_hash{STATUS}             = 'ISSUED';
    $insert_hash{PKI_REALM}          = $realm;
    $insert_hash{CERTIFICATE_SERIAL} = $cert->get_serial();
    $insert_hash{IDENTIFIER}         = $cert->get_identifier();
    $insert_hash{DATA}               = $extracted_certdata;
    $insert_hash{SUBJECT}            = $cert->{PARSED}->{BODY}->{SUBJECT};
    $insert_hash{ISSUER_DN}          = $cert->{PARSED}->{BODY}->{ISSUER};
    $insert_hash{ISSUER_IDENTIFIER}  = $issuer_identifier;

    # combine email addresses
    if ( exists $cert->{PARSED}->{BODY}->{EMAILADDRESSES} ) {
        $insert_hash{EMAIL} = '';
        foreach my $email ( @{ $cert->{PARSED}->{BODY}->{EMAILADDRESSES} } )
        {
            $insert_hash{EMAIL} .= "," if ( $insert_hash{EMAIL} ne '' );
            $insert_hash{EMAIL} .= $email;
        }
    }
    $insert_hash{PUBKEY} = $cert->{PARSED}->{BODY}->{PUBKEY};

    # set subject key id and authority key id, if defined.
    if ( defined $cert->get_subject_key_id() ) {
        $insert_hash{SUBJECT_KEY_IDENTIFIER} = $cert->get_subject_key_id();
    }
    if ( defined $cert->get_authority_key_id()
        && ref $cert->get_authority_key_id() eq '' )
    {

        # TODO: do we save if authority key id is hash, and if
        # yes, in which format?
        $insert_hash{AUTHORITY_KEY_IDENTIFIER} =
          $cert->get_authority_key_id();
    }

    $insert_hash{NOTAFTER} = OpenXPKI::DateTime::convert_date(
        {
            DATE      => $cert->{PARSED}->{BODY}->{NOTAFTER},
            OUTFORMAT => 'epoch',
        }
    );
    $insert_hash{NOTBEFORE} = OpenXPKI::DateTime::convert_date(
        {
            DATE      => $cert->{PARSED}->{BODY}->{NOTBEFORE},
            OUTFORMAT => 'epoch',
        }
    );

    # fields which are explicitly NOT set:
    # LOA          (we don't know it)
    # CSR_SERIAL   ( " " )

    # check whether there is already a certificate with the given
    # identifier anywhere
    my $certificate = $dbi->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { IDENTIFIER => $insert_hash{IDENTIFIER}, },
    );
    if ( defined $certificate
        && !defined $params{'force-certificate-already-exists'} )
    {
        if ( $certificate->{PKI_REALM} ) {
            print STDERR "ERROR: The same certificate already exists "
              . "in the $certificate->{PKI_REALM} realm. Use openxpkiadm "
              . "certificate alias to reference it.\n";
        }
        else {
            print STDERR "ERROR: The same certificate already exists  "
              . "as a global self-signed certificate. Use openxpkiadm "
              . "certificate alias to reference it.\n";
        }
        return 2;
    }
    $dbi->insert(
        TABLE => 'CERTIFICATE',    # use hash method
        HASH  => \%insert_hash,
    );
    $dbi->commit();

    print "Successfully imported certificate into database:\n";
    print "  Subject:    " . $insert_hash{SUBJECT} . "\n";
    print "  Issuer:     " . $insert_hash{ISSUER_DN} . "\n";
    print "  Identifier: " . $insert_hash{IDENTIFIER} . "\n";
    return 0;

}


sub certificate_remove {

    my $name  = $params{name};
    my $realm = $params{realm};

    my $identifier = $name;

    my $dbi = __get_dbi();

    if ( defined $realm ) {
        $identifier = __resolve_alias(
            {
                DBI   => $dbi,
                NAME  => $name,
                REALM => $realm,
            }
        );
    }

    # check if certificate is issuer of something
    my $children_dbi = $dbi->select(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { ISSUER_IDENTIFIER => $identifier, },
    );
    my @children = @{$children_dbi};

    my $is_issuer = 0;
    if ( scalar @children > 0 ) {
        $is_issuer = 1;
        if ( scalar @children == 1 ) {
            if ( $children[0]->{'ISSUER_IDENTIFIER'} eq $identifier ) {

                # only self-signed certificate, delete even though
                # it formally is the issuer of a certificate in the DB
                $is_issuer = 0;
            }
        }
    }

    if ( $is_issuer && !defined $params{'force-is-issuer'} ) {
        print STDERR "ERROR: Certificate not deleted because it is referenced as the issuer of "
          . scalar @children
          . " certificate(s) in the database.\n";
        return 2;
    }
    my $certificate = $dbi->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { IDENTIFIER => $identifier, },
    );
    if ( defined $certificate ) {
        $dbi->delete(
            TABLE => 'CERTIFICATE',
            DATA  => { IDENTIFIER => $identifier, },
        );
        $dbi->commit();
        print "Successfully deleted certificate $name "
          . "(identifier: $identifier) from database.\n";
        return 0;
    }
    else {
        print STDERR "ERROR: Certificate $name "
          . "(identifier: $identifier) not found in database.\n";
        return 2;
    }
}

sub alias_add {

    my %insert_hash = ();

    my $dbi = __get_dbi();

    $insert_hash{PKI_REALM} = $params{realm};

    # Import of named tokens always ba group and generation
    if ( $params{token} ) {

        my $group = ($params{token} eq "root") ? 'root' :
            CTX('config')->get("realm.$params{realm}.crypto.type.$params{token}");

        if (!$group) {
            print STDERR "There is no token of type $params{token} defined\n";
            return 2;
        }
        # query aliases to get next generation id
        my $next_generation = $dbi->first(
            TABLE   => 'ALIASES',
            DYNAMIC => {
                PKI_REALM => $params{realm},
                GROUP_ID => $group,
            },
            'ORDER' => [ 'GENERATION' ],
            'REVERSE' => 1,
        );
        $insert_hash{GENERATION} = ($next_generation->{GENERATION} || 0) + 1;
        $insert_hash{GROUP_ID} = $group;
        $insert_hash{ALIAS} = sprintf "%s-%01d", $group, $insert_hash{GENERATION};

    } elsif ( $params{group} && $params{gen} ) {

        $insert_hash{GENERATION} = $params{gen};
        $insert_hash{GROUP_ID} = $params{group};
        $insert_hash{ALIAS} = sprintf "%s-%01d", $params{group}, $params{gen};

    } elsif ( !exists( $params{alias} ) || $params{alias} eq '' ) {
        print STDERR "Please specify an alias with --alias\n";
        return 1;

    } else {

        $insert_hash{ALIAS} = $params{alias};
    }

    if ( !exists( $params{identifier} ) || $params{identifier} eq '' ) {
        print STDERR "Please specify an identifier with --identifier\n";
        return 1;
    } else {
        $insert_hash{IDENTIFIER} = $params{identifier};
    }

    # Prevent duplicate entries (each identifier is allowed only once per group)
    my $duplicate_alias = $dbi->first(
        TABLE   => 'ALIASES',
        DYNAMIC => { IDENTIFIER => $insert_hash{IDENTIFIER}, PKI_REALM => $params{realm}, 'GROUP_ID' => $insert_hash{GROUP_ID} },
    );

    if ($duplicate_alias) {
        print STDERR "ERROR: certificate already exisits in group\n";
        print STDERR "Alias: " . $duplicate_alias->{ALIAS} . "\n";
        return 2;
    }

    # query certificate table to check whether --identifer actually exists
    my $certificate = $dbi->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { IDENTIFIER => $insert_hash{IDENTIFIER}, },
    );

    if ( !defined $certificate ) {
        # there is no cert with given identifier
        print STDERR "ERROR: Could not find a certificate with "
          . "identifier '$insert_hash{IDENTIFIER}', ";
        return 2;
    }

    if ($params{notbefore}) {
        if ($params{notbefore} =~ /^\d+$/) {
            $insert_hash{NOTBEFORE} = $params{notbefore};
        } else {

            my $dt;
            eval {
                $dt = OpenXPKI::DateTime::parse_date_utc( $params{notbefore} );
            };
            if ($EVAL_ERROR || !$dt) {
                print STDERR "ERROR: Could not parse notbefore date";
                return 1;
            }

            $insert_hash{NOTBEFORE} = $dt->epoch();

            if ($insert_hash{NOTBEFORE} < $certificate->{NOTBEFORE}) {
                print STDERR "ERROR: notbefore exceeds certificate validity";
                return 1;
            }
        }
    } else {
        $insert_hash{NOTBEFORE} = $certificate->{NOTBEFORE};
    }


    if ($params{notafter}) {
        if ($params{notafter} =~ /^\d+$/) {
            $insert_hash{NOTAFTER} = $params{notafter};
        } else {
            my $dt;
            eval {
                $dt = OpenXPKI::DateTime::parse_date_utc( $params{notafter} );
            };
            if ($EVAL_ERROR || !$dt) {
                print STDERR "ERROR: Could not parse notafter date";
                return 1;
            }
            $insert_hash{NOTAFTER} = $dt->epoch();

            if ($insert_hash{NOTAFTER} > $certificate->{NOTAFTER}) {
                print STDERR "ERROR: notafter exceeds certificate validity";
                return 1;
            }
        }
    } else {
        $insert_hash{NOTAFTER} = $certificate->{NOTAFTER};
    }

    #### insert_hash : Dumper(\%insert_hash)
    $dbi->insert(
        TABLE => 'ALIASES',
        HASH  => \%insert_hash,
    );
    $dbi->commit();

    print "Successfully created alias in realm $params{realm}:\n";
    __alias_print( \%insert_hash, $certificate );


    # Check if the alias is for an issuing ca cert -> create root ca alias
    my $cs_group = CTX('config')->get("realm.$params{realm}.crypto.type.certsign");
    if ( $insert_hash{ALIAS} =~ /^$cs_group-(\d+)/ ) {
        print "\nToken is certsign, looking for root...\n";
        my $gen = $1;

        my $chain_ref = CTX('api')->get_chain({ 'START_IDENTIFIER' => $insert_hash{IDENTIFIER} });

        if ($chain_ref->{COMPLETE} != 1) {
            print STDERR "ERROR: unable to find root certificate";
            return 2;
        }
        my $root_identifier = pop @{$chain_ref->{IDENTIFIERS}};

        # check if this root is already definde
        my $root_alias = $dbi->first(
            TABLE   => 'ALIASES',
            DYNAMIC => { IDENTIFIER => $root_identifier, PKI_REALM => $params{realm}, 'GROUP_ID' => 'root' },
        );
        if ($root_alias) {
            print "Root ca already in alias table:\n";
        } else {
            print "Creating alias for root ca:\n";
            # Get the notebefore/notafter date
            $certificate = $dbi->first(
                TABLE   => 'CERTIFICATE',
                COLUMNS => ['NOTBEFORE' , 'NOTAFTER' ],
                DYNAMIC => { IDENTIFIER => $root_identifier },
            );

            $root_alias = {
                IDENTIFIER => $root_identifier,
                PKI_REALM => $params{realm},
                GROUP_ID => 'root',
                GENERATION => $gen,
                ALIAS => sprintf ('root-%01d', $gen),
                NOTBEFORE => $certificate->{NOTBEFORE},
                NOTAFTER => $certificate->{NOTAFTER},
            };
            $dbi->insert(
                TABLE => 'ALIASES',
                HASH  => $root_alias,
            );
            $dbi->commit();
        }

        __alias_print( $root_alias );

    }

    return 0;

}

sub alias_update {

    my %query_hash = (
        PKI_REALM =>  $params{realm}
    );

    if ($params{identifier}) {
        $query_hash{IDENTIFIER} = $params{identifier};
    } elsif ($params{alias}) {
        $query_hash{ALIAS} = $params{alias};
    } else {
        print STDERR "You must specify either --identifier or --alias\n";
        return 1;
    }

    my $dbi = __get_dbi();

    my $alias = $dbi->first(
        TABLE   => 'ALIASES',
        DYNAMIC => \%query_hash,
    );

    if (!$alias) {
        print STDERR "No alias entry found matching your request\n";
        return 2;
    }

    my %update_hash = ();

    # query certificate table to check whether --identifer actually exists
    my $certificate = $dbi->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { IDENTIFIER => $alias->{IDENTIFIER}, },
    );

    if ($params{notbefore}) {
        if ($params{notbefore} =~ /^\d+$/) {
            $update_hash{NOTBEFORE} = $params{notbefore};
        } else {
            my $dt;
            eval {
                $dt = OpenXPKI::DateTime::parse_date_utc( $params{notbefore} );
            };
            if ($EVAL_ERROR || !$dt) {
                print STDERR "ERROR: Could not parse notbefore date";
                return 2;
            }
            $update_hash{NOTBEFORE} = $dt->epoch();

            if ($update_hash{NOTBEFORE} < $certificate->{NOTBEFORE}) {
                print STDERR "ERROR: notbefore exceeds certificate validity";
                return 2;
            }
        }
    } elsif(defined $params{notbefore}) {
        $update_hash{NOTBEFORE} = $certificate->{NOTBEFORE};
    }

    if ($params{notafter}) {
        if ($params{notafter} =~ /^\d+$/) {
            $update_hash{NOTAFTER} = $params{notafter};
        } else {
            my $dt;
            eval {
                $dt = OpenXPKI::DateTime::parse_date_utc( $params{notafter} );
            };
            if ($EVAL_ERROR || !$dt) {
                print STDERR "ERROR: Could not parse notafter date";
                return 2;
            }
            $update_hash{NOTAFTER} = $dt->epoch();

            if ($update_hash{NOTAFTER} > $certificate->{NOTAFTER}) {
                print STDERR "ERROR: notafter exceeds certificate validity";
                return 2;
            }
        }
    } elsif(defined $params{notafter}) {
        $update_hash{NOTAFTER} = $certificate->{NOTAFTER};
    }

    if (!%update_hash) {
        print STDERR "ERROR: please specify at least notbefore or notafter";
        return 1;
    }

    $dbi->update(
        TABLE => 'ALIASES',
        DATA => \%update_hash,
        WHERE => {
            ALIAS =>  $alias->{ALIAS},
            PKI_REALM => $alias->{PKI_REALM}
        }
    );
    $dbi->commit();

    $alias = $dbi->first(
        TABLE   => 'ALIASES',
        DYNAMIC => \%query_hash,
    );

    print "Successfully updated alias:\n";
    __alias_print( $alias, $certificate );


    return 0;

}

sub alias_list {

    my $realm = $params{realm};
    # get names of groups
    my $groups = CTX('config')->get_hash("realm.$realm.crypto.type");

    my $dbi = __get_dbi();
    my $alias;
    my $cert;

    # Load the list of exisiting aliased groups as there can be custom tokens
    # outside the main groups (e.g. alternative scep tokens)
    my $db_results = $dbi->select(
        TABLE   => 'ALIASES',
        DYNAMIC => {
            'PKI_REALM' => { VALUE => $realm },
            'NOTBEFORE' => { VALUE => time(), OPERATOR => 'LESS_THAN' },
            'NOTAFTER' => { VALUE => time(), OPERATOR => 'GREATER_THAN' },
        },
        'ORDER' => [ 'NOTBEFORE' ],
        'REVERSE' => 1,
    );

    my %anon_groups;
    foreach my $entry (@{ $db_results }) {
        $anon_groups{ $entry->{GROUP_ID} } = 1;
    }
    # remove root from the list
    delete $anon_groups{'root'};

    print "=== functional token ===\n";
    foreach my $type (keys %{$groups}) {

        my $group = $groups->{$type};
        print "$group ($type):\n";

        $alias = $dbi->first(
            TABLE   => 'ALIASES',
            DYNAMIC => {
                'PKI_REALM' => { VALUE => $realm },
                'GROUP_ID' => { VALUE => $group },
                'NOTBEFORE' => { VALUE => time(), OPERATOR => 'LESS_THAN' },
                'NOTAFTER' => { VALUE => time(), OPERATOR => 'GREATER_THAN' },
            },
            'ORDER' => [ 'NOTBEFORE' ],
            'REVERSE' => 1,
        );

        $cert = $dbi->first(
            TABLE   => 'CERTIFICATE',
            DYNAMIC => { IDENTIFIER => { VALUE => $alias->{IDENTIFIER} }, },
        );

        __alias_print( $alias, $cert );

       # unset in anon group list
       delete $anon_groups{$group};

    }

    print "=== anonymous groups ===\n" if (%anon_groups);
    foreach my $group (keys %anon_groups) {

        print "$group:\n";

        $alias = $dbi->first(
            TABLE   => 'ALIASES',
            DYNAMIC => {
                'PKI_REALM' => { VALUE => $realm },
                'GROUP_ID' => { VALUE => $group },
                'NOTBEFORE' => { VALUE => time(), OPERATOR => 'LESS_THAN' },
                'NOTAFTER' => { VALUE => time(), OPERATOR => 'GREATER_THAN' },
            },
            'ORDER' => [ 'NOTBEFORE' ],
            'REVERSE' => 1,
        );

        $cert = $dbi->first(
            TABLE   => 'CERTIFICATE',
            DYNAMIC => { IDENTIFIER => { VALUE => $alias->{IDENTIFIER} }, },
        );

        __alias_print( $alias, $cert );

    }

    # Check for root ca
    $alias = $dbi->first(
        TABLE   => 'ALIASES',
        DYNAMIC => {
            'PKI_REALM' => { VALUE => $realm },
            'GROUP_ID' => { VALUE => 'root' },
            'NOTBEFORE' => { VALUE => time(), OPERATOR => 'LESS_THAN' },
            'NOTAFTER' => { VALUE => time(), OPERATOR => 'GREATER_THAN' },
        },
        'ORDER' => [ 'NOTBEFORE' ],
        'REVERSE' => 1,
    );
    $cert = CTX('dbi_backend')->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { IDENTIFIER => { VALUE => $alias->{IDENTIFIER} }, },
    );

    print "=== root ca ===\ncurrent root ca:\n";
    __alias_print( $alias, $cert );

    # Check for root ca
    $alias = $dbi->first(
        TABLE   => 'ALIASES',
        DYNAMIC => {
            'PKI_REALM' => { VALUE => $realm },
            'GROUP_ID' => { VALUE => 'root' },
            'NOTBEFORE' => { VALUE => time(), OPERATOR => 'GREATER_THAN' },
        },
        'ORDER' => [ 'NOTBEFORE' ],
    );

    $cert = CTX('dbi_backend')->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { IDENTIFIER => { VALUE => $alias->{IDENTIFIER} }, },
    );

    print "upcoming root ca:\n";
    __alias_print( $alias, $cert );


    return 0;


}

sub __alias_print {

    my $alias = shift;
    my $cert = shift;

    if (!$alias || !$alias->{ALIAS}) {
        print "  not set\n\n";
        return;
    }

    print "  Alias     : $alias->{ALIAS}\n";
    print "  Identifier: $alias->{IDENTIFIER}\n";
    print "  NotBefore : " . DateTime->from_epoch( epoch => $alias->{NOTBEFORE} )->strftime("%F %T");

    print DateTime->from_epoch( epoch => $cert->{NOTBEFORE} )->strftime(" (%F %T)")
        if ($cert && $cert->{NOTBEFORE} != $alias->{NOTBEFORE});

    print "\n";
    print "  NotAfter  : " . DateTime->from_epoch( epoch => $alias->{NOTAFTER} )->strftime("%F %T");

    print DateTime->from_epoch( epoch => $cert->{NOTAFTER} )->strftime(" (%F %T)")
        if ($cert && $cert->{NOTAFTER} != $alias->{NOTAFTER});

    print "\n\n";

}


sub certificate_chain {

    my $cert_name;
    my $issuer_name;
    if ( !exists( $params{name} ) || $params{name} eq '' ) {
        print STDERR "Please specify a certificate name with --name\n";
        return 1;
    }
    else {
        $cert_name = $params{name};
    }
    if ( !exists( $params{issuer} ) || $params{issuer} eq '' ) {
        print STDERR "Please specify an issuer name with --issuer\n";
        return 1;
    }
    else {
        $issuer_name = $params{issuer};
    }

    my $dbi = __get_dbi();

    # maybe the certificate name is an alias, try to resolve it
    my $cert_identifier = __resolve_alias(
        {
            DBI   => $dbi,
            NAME  => $cert_name,
            REALM => $params{realm},
        }
    );

    # check whether the certificate is in the DB
    my $certificate = $dbi->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => {
            IDENTIFIER => $cert_identifier,
            PKI_REALM  => $params{realm}
        },
    );
    if (   !defined $certificate
        && !defined $params{'force-certificate-not-found'} )
    {
        print STDERR "ERROR: Certificate '$cert_name' not found in realm "
          . "$params{realm}.\n";
        return 2;
    }

    my $issuer_identifier;

    # maybe the issuer name is an alias, try resolve it
    my $realm;
    if ( defined $params{'issuer-realm'} ) {
        $realm = $params{'issuer-realm'};
    }
    else {
        $realm = $params{realm};
    }
    $issuer_identifier = __resolve_alias(
        {
            DBI   => $dbi,
            NAME  => $issuer_name,
            REALM => $realm,
        }
    );

    # check whether the issuer is in the DB
    my $issuer = $dbi->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { IDENTIFIER => $issuer_identifier, },
    );
    if (   !defined $issuer
        && !defined $params{'force-issuer-certificate-not-found'} )
    {
        print STDERR "ERROR: Issuer certificate '$issuer_name' "
          . "(identifier: $issuer_identifier) not found in database.\n";
        return 2;
    }

    # set the issuer_identifier for the given certificate
    $dbi->update(
        TABLE => 'CERTIFICATE',
        DATA  => { ISSUER_IDENTIFIER => $issuer_identifier, },
        WHERE => {
            CERTIFICATE_SERIAL => $certificate->{CERTIFICATE_SERIAL},
            IDENTIFIER         => $cert_identifier,
            PKI_REALM          => $certificate->{PKI_REALM},
        },
    );
    $dbi->commit();
    print "Successfully set $issuer_name (identifier: $issuer_identifier) "
      . "as issuer of certificate $cert_name (identifier: "
      . "$cert_identifier).\n";

    # TODO: maybe don't warn only, but let the user use --force to
    # specify that he knows what he is doing ...?
    if ( $issuer->{SUBJECT_KEY_IDENTIFIER} ne
        $certificate->{AUTHORITY_KEY_IDENTIFIER} )
    {
        print STDERR "WARNING: The issuer's subject key identifier "
          . "extension ($issuer->{SUBJECT_KEY_IDENTIFIER}) does not "
          . "match the authority key identifier extension contained "
          . "in the certificate "
          . "($certificate->{AUTHORITY_KEY_IDENTIFIER}). Are you sure "
          . "your chain is correct?\n";
    }
    if ( $issuer->{SUBJECT} ne $certificate->{ISSUER_DN} ) {
        print STDERR "WARNING: The issuer's subject ($issuer->{SUBJECT}) "
          . "does not match the issuer DN contained in the certificate "
          . "($certificate->{ISSUER_DN}). Are you sure your chain is "
          . "correct?\n";
    }
    return 0;

}

sub certificate_list {

    my @realms;
    if ( defined $params{realm} ) {
        push @realms, $params{realm};
    }
    else {
        @realms = CTX('config')->get_keys('system.realms');
        push @realms, undef;    # add the magic empty realm
    }

    my $dbi = __get_dbi();
    foreach my $realm (@realms) {
        if ( defined $realm ) {
            print "\nCertificates in $realm:\n";
        }
        else {
            print "\nCertificates in self-signed pseudo-realm:\n";
        }
        my $certificates;
        if ( defined $params{all} ) {
            $certificates = $dbi->select(
                TABLE   => 'CERTIFICATE',
                DYNAMIC => { PKI_REALM => $realm, },
            );
        }
        else {
            $certificates = $dbi->select(
                TABLE   => [ 'ALIASES', 'CERTIFICATE' ],
                COLUMNS => [
                    'ALIASES.ALIAS',
                    'ALIASES.IDENTIFIER',
                    'CERTIFICATE.SUBJECT',
                    'CERTIFICATE.ISSUER_DN',
                    'CERTIFICATE.CERTIFICATE_SERIAL',
                    'CERTIFICATE.ISSUER_IDENTIFIER',
                    'CERTIFICATE.DATA',
                    'CERTIFICATE.EMAIL',
                    'CERTIFICATE.STATUS',
                    'CERTIFICATE.ROLE',
                    'CERTIFICATE.PUBKEY',
                    'CERTIFICATE.SUBJECT_KEY_IDENTIFIER',
                    'CERTIFICATE.AUTHORITY_KEY_IDENTIFIER',
                    'CERTIFICATE.NOTAFTER',
                    'CERTIFICATE.LOA',
                    'CERTIFICATE.NOTBEFORE',
                    'CERTIFICATE.CSR_SERIAL',
                ],
                JOIN => [ [ 'IDENTIFIER', 'IDENTIFIER', ], ],
                DYNAMIC => { 'ALIASES.PKI_REALM' => $realm, },
            );
        }
        for ( my $i = 0 ; $i < scalar @{$certificates} ; $i++ ) {
            my $cert = $certificates->[$i];
            my $identifier;
            if ( defined $params{all} ) {    # look up aliases
                $identifier = $cert->{IDENTIFIER};
                my $status = $cert->{STATUS};
                if ( defined $status && $status eq 'REVOKED' ) {
                    print "\n  Identifier: "
                      . $cert->{IDENTIFIER}
                      . " (REVOKED)\n";
                }
                else {
                    print "\n  Identifier: " . $cert->{IDENTIFIER} . "\n";
                }
                my $aliases = $dbi->select(
                    TABLE   => 'ALIASES',
                    DYNAMIC => { IDENTIFIER => $cert->{IDENTIFIER}, },
                );
                for ( my $j = 0 ; $j < scalar @{$aliases} ; $j++ ) {
                    print "    Alias:\n      "
                      . $aliases->[$j]->{ALIAS}
                      . " (in realm: "
                      . $aliases->[$j]->{PKI_REALM} . ")\n";
                }
            }
            else {
                $identifier = $cert->{'ALIASES.IDENTIFIER'};
                my $status = $cert->{'CERTIFICATE.STATUS'};
                if ( defined $status && $status eq 'REVOKED' ) {
                    print "\n  Identifier: "
                      . $cert->{'ALIASES.IDENTIFIER'}
                      . " (REVOKED)\n";
                }
                else {
                    print "\n  Identifier: "
                      . $cert->{'ALIASES.IDENTIFIER'} . "\n";
                }
                print "    Alias:\n       "
                  . $cert->{'ALIASES.ALIAS'} . "\n";
            }
            my $prefix = '';
            if ( !defined $params{all} ) {
                $prefix = 'CERTIFICATE.';
            }
            if ( defined $params{v} && $params{v} > 0 ) {

                # show subject and issuer dn
                my $subject   = $cert->{ $prefix . 'SUBJECT' };
                my $issuer_dn = $cert->{ $prefix . 'ISSUER_DN' };
                print "    Subject:\n      " . $subject . "\n";
                print "    Issuer DN:\n      " . $issuer_dn . "\n";
            }
            if ( defined $params{v} && $params{v} > 1 ) {

                # show chain
                my $api = CTX('api');
                my $chain =
                  $api->get_chain( { START_IDENTIFIER => $identifier, } );
                my $chain_str = join( ' -> ', @{ $chain->{IDENTIFIERS} } );

                print "    Chain: $chain_str ";
                if ( $chain->{COMPLETE} == 1 ) {
                    print "(complete)\n";
                }
                else {
                    print "(INcomplete!)\n";
                }
            }
            if ( defined $params{v} && $params{v} > 2 ) {

                # show database entry
                my @fields = qw(
                  SUBJECT_KEY_IDENTIFIER
                  AUTHORITY_KEY_IDENTIFIER
                  CERTIFICATE_SERIAL
                  ISSUER_IDENTIFIER
                  EMAIL
                  STATUS
                  ROLE
                  NOTAFTER
                  NOTBEFORE
                  CSR_SERIAL
                  LOA
                );

                if ( $params{v} > 3 ) {
                    push @fields, qw(PUBKEY DATA);
                }

                foreach my $field (@fields) {
                    my $value;
                    if ( defined $cert->{ $prefix . $field } ) {
                        $value = $cert->{ $prefix . $field };
                    }
                    else {
                        $value = 'NULL';
                    }
                    print "    $field:\n      " . $value . "\n";
                }
            }
        }
    }
    exit 0;
}

sub alias_del {

    my %delete_hash = ();

    $delete_hash{PKI_REALM} = $params{realm};

    if ($params{identifier}) {
        $delete_hash{IDENTIFIER} = $params{identifier};
    } elsif ($params{alias}) {
        $delete_hash{ALIAS} = $params{alias};
    } else {
        print STDERR "You must specify either --identifier or --alias\n";
        return 1;
    }

    my $dbi = __get_dbi();

    my $alias = $dbi->first(
        TABLE   => 'ALIASES',
        DYNAMIC => \%delete_hash,
    );

    if (!$alias) {
        print STDERR "No alias entry found matching your request\n";
        return 2;
    }

    $dbi->delete(TABLE => 'ALIASES', DATA => {
        ALIAS => $alias->{ALIAS},
        PKI_REALM => $alias->{PKI_REALM},
    });
    $dbi->commit();

    print "Successfully removed the alias $alias->{ALIAS}:\n";
    print "   Identifier: $alias->{IDENTIFIER}\n";
    print "   Realm:      $alias->{PKI_REALM}\n";

    return 0;

}

sub key_list {

    my $dbi = __get_dbi();
    my $config = CTX('config');
    my $realm = $params{realm};

    # TODO - Improve!
    # We use the alias table to find all keys in the realm
    # For the moment we assume the keys are defined explicit in the config
    # this will change in the future when we allow autodiscovery and default inheritance
    my $token_class = $config->get_hash("realm.$realm.crypto.type");

    foreach my $class (keys %{$token_class}) {
        my $db_alias = $dbi->select(
            TABLE   => 'ALIASES',
            DYNAMIC => {
                GROUP_ID     => $token_class->{$class},
                PKI_REALM => $realm,
            },
        );

        print "Keys for token group $token_class->{$class}\n";
        foreach my $entry (@{ $db_alias }) {
            my $alias = $entry->{ALIAS};
            my $key = $config->get("realm.$realm.crypto.token.$alias.key");

            my $status_flag = '?';
            if (!$key) {
                $status_flag = 'c';
            }elsif ( -e $key && ( !-s $key ) ) {
                $status_flag = '0';    # file exists but is of size zero
            }   elsif ( -e $key ) {        # file exists and is non-zero
                $status_flag = '+';
            } else {                     # file does not exist (yet)
                $status_flag = '!';
            }
            print '    ' . $status_flag . ' ' . $alias . "\n";
        }
    }

    return 0;
}

sub hash_password {

    print 'Please type your password, end with return: ';
    my $passwd = prompt -echo => '*';

    print "Please re-type your password: ";
    my $retype = prompt -echo => '*';

    chomp $passwd;
    chomp $retype;

    if (!$passwd) {
        return 0;
    }

    if ($passwd ne $retype) {
        print "Sorry, the passwords do not match\n";
        return 0;
    }

    # Use openssl to create the salt
    my @exec = ('openssl','rand','-base64','3');
    my ($salt, undef) = Proc::SafeExec::backtick(@exec);
    chomp $salt;

    my $computed_secret;
    if ($params{scheme} eq 'sha') {
        my $ctx = Digest::SHA->new();
        $ctx->add($passwd);
        $computed_secret = $ctx->b64digest();
    } elsif ($params{scheme} eq 'ssha') {
        my $ctx = Digest::SHA->new();
        $ctx->add($passwd);
        $ctx->add($salt);
        $computed_secret = encode_base64( $ctx->digest() . $salt, '');
    } elsif ($params{scheme} eq 'md5') {
        my $ctx = Digest::MD5->new();
        $ctx->add($passwd);
        $computed_secret = $ctx->b64digest();
    } elsif ($params{scheme} eq 'smd5') {
        my $ctx = Digest::MD5->new();
        $ctx->add($passwd);
        $ctx->add($salt);
        $computed_secret = encode_base64($ctx->digest() . $salt, '');
    } elsif ($params{scheme} eq 'crypt') {
        $computed_secret = crypt($passwd, $salt);
    }

    if (!$computed_secret) {
        die "Unable to compute hash\n";
    }

    printf "Your hashed password is: {%s}%s\n", $params{scheme}, $computed_secret;

    return 0;
}

sub __get_dbi {

    my $dbi = CTX('dbi_backend');
    if ( !defined $dbi ) {
        die "ERROR: Could not instantiate database backend\n";
    }
    $dbi->connect();
    return $dbi;
}

sub __resolve_alias {

    my $arg_ref = shift;
    my $dbi     = $arg_ref->{DBI};
    my $name    = $arg_ref->{NAME};
    my $realm   = $arg_ref->{REALM};

    my $alias = $dbi->first(
        TABLE   => 'ALIASES',
        DYNAMIC => {
            ALIAS     => $name,
            PKI_REALM => $realm,
        },
    );
    if ( defined $alias ) {
        return $alias->{IDENTIFIER};
    }
    else {
        return $name;
    }
}

sub __init {

    GetOptions( \%params, @options_spec ) or pod2usage( -verbose => 0 );

    if ($params{config}) {
        # we set the ENV here to outrule an external ENV setting and to have
        # it ready for the reload action (needed to find the correct pidfile)
        $ENV{OPENXPKI_CONF_DB} = $params{config};
    }

}

if ($cmd eq 'initdb') {

    OpenXPKI::Server::Init::init({TASKS  => ['config_versioned'], SILENT => 1,});

    push @options_spec, qw(dry-run force);
    __init();
    $ret = initdb();

} elsif ($cmd eq 'loadcfg') {

    push @options_spec, qw(
        path=s
        config|dbpath=s
        reload
    );
    __init();
    $ret = loadcfg();

} elsif ($cmd eq 'certificate') {

    my $subcmd = shift;

    OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','dbi_log','log','api','crypto_layer','dbi_backend'], SILENT => 1, CLI => 1});



    if ($subcmd eq 'id') {

        push @options_spec, qw(
            file=s
            format=s
        );
        __init();
        $ret = certificate_id();

    } elsif ($subcmd eq 'import') {

        push @options_spec, qw(
            realm=s
            file=s
            issuer=s
            issuer-realm=s
            role=s
            force-really-self-signed
            force-issuer-not-found
            force-certificate-already-exists
            );

        __init();
        if (!$params{file}) {
            die "You need to specify the certificate to import with --file\n";
        }

        if (!$params{issuer} && defined $params{realm}) {
            die "You must specify --issuer and --realm or leave both empty\n";
        }

        if ((!$params{alias} && $params{group}) || ($params{alias} && !$params{group})) {
            die "You must always specify both --alias and --group \n";
        }

        $ret = certificate_import();

    } elsif ($subcmd eq 'remove') {

        push @options_spec, qw(
            realm=s
            name=s
            force-is-issuer
        );
        __init();
        $ret = certificate_remove();

    } elsif ($subcmd eq 'chain') {

        push @options_spec, qw(
            issuer=s
            issuer-realm=s
            name=s
            force-certificate-not-found
            force-issuer-certificate-not-found
        );
        __init();
        $ret = certificate_chain();

    } elsif ($subcmd eq 'list') {

        push @options_spec, qw(
            realm=s
            all
            v+
        );
        __init();
        $ret = certificate_list();
    }


} elsif ($cmd eq 'alias') {

    OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','dbi_log','log','api','dbi_backend'], SILENT => 1, CLI => 1});

    push @options_spec, qw(
      alias=s
      remove
      update
      notbefore=s
      notafter=s
      realm=s
      gen|generation=s
      group=s
      token=s
      identifier=s
    );
    __init();

    if (!$params{realm}) {
        die "You must specify a realm using --realm\n";
    }

    if ($params{remove}) {
        $ret = alias_del();
    } elsif ($params{update}) {
        $ret = alias_update();
    } elsif (!$params{identifier}) {
        $ret = alias_list();
    } else {
        $ret = alias_add();
    }
} elsif ($cmd eq 'key') {

    my $subcmd = shift;

    if ($subcmd eq 'list') {

        OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','api','dbi_backend'], SILENT => 1,});

        push @options_spec, qw(
          realm=s
        );
        __init();

        if (!$params{realm}) {
            die "You must specify a realm using --realm\n";
        }

        $ret = key_list();

    }
} elsif ($cmd eq 'hashpwd') {

    push @options_spec, qw(
          scheme|s=s
    );
    __init();

    if (!$params{scheme}) {
        $params{scheme} = 'ssha';
    } elsif ($params{scheme} !~ /^(sha|ssha|md5|smd5|crypt)$/) {
        die "Unsupported scheme - supported values: sha|ssha|md5|smd5|crypt\n";
    }

    $ret = hash_password();
}


if ($ret) {
    print "\n";
    pod2usage( -verbose => 0 ) if ($ret == 1);
    exit $ret;
}

exit 0;

1;


__END__

=head1 NAME

openxpkiadm - tool for management operations of OpenXPKI instances

=head1 USAGE

openxpkiadm COMMAND [SUBCOMMAND] [OPTIONS]

 Global options:
   --config DIR          Location of the configuration repository
                         optional, defaults to /etc/openxpki/config.git

 Commands:
   help                  brief help message
   man                   full documentation
   version               print program version and exit
   initdb                Initialize database
   key                   Manage keys
   certificate           Manage certificates
   loadcfg               Import updated config from the filesystem
   hashpwd               Create the salted hash for a password
   alias                 Manage the token alias table

=head1 ARGUMENTS

Available commands:

=head2 initdb

Command options:

   --force               Force operation (may be destructive)
   --dryrun              Don't change anything, just print what would
                         be done

Initializes the OpenXPKI database schema. Will not destroy existing data
unless called with --force.

=head2 key

Key management for OpenXPKI Tokens (including issuing CAs and subsystems).

Command options:

   --realm               PKI Realm to operate on

=head3 key management subcommands

=over 8

=item B<list>

Shows token key information for the specified realm, including
key algorithm, key length and secret splitting information.
TODO: Key info not implemented yet!

Lists keys together with a status flag, which can be one of the
following:

  c - token not defined in crypto.token
  + - key exists and file is non-empty
  0 - key exists but file is empty
  ! - key files does not exist (yet)


Example:

  openxpkiadm key list --realm 'Root CA'

=back

=head2 certificate

Starts a certificate management command and allows to list, install,
delete and connect certificates for the configured PKI Realms.

  openxpkiadm certificate <subcommand> <options>

=head3 certificate management subcommands

=over 8

=item B<list>

Subcommand options (optional):

   --realm                  PKI realm to operate on
   --all                    Show all certificates
   -v                       Show subject and issuer DN as well
   -v -v                    Show chain as well
   -v -v -v                 Show (nearly complete) database entry
   -v -v -v -v              Show pubkey and certificate data, too

Lists certificates present in the database for
the specified realm. If --all is not specified, only certificates
that have an alias defined for them are listed. --all lists all
certificates, regardless of whether they have an alias or not.
If --realm is left out, the certificates in all realms are listed
The number of -v's increases the verbosity (see above for what is
listed in which case).

=item B<import>

Subcommand options:

Mandatory:
  --realm                   PKI realm to import certificate to
  --file                    the PEM file to import from
  --issuer                  the issuer alias or identifier

Optional:
  --issuer-realm            the realm where the issuer alias
                            is defined
  --role                    the role of the certificate owner

Force options (use only if you exactly now what you are doing!):
  --force-really-self-signed
        The certificate is really self-signed
  --force-issuer-not-found
        Don't care that the issuer is not in the database
  --force-certificate-already-exists
        Don't care that the certificate is already in database

Once again, only use these options if you actually have to (the
occasions where this happens should be really, really rare).

Adds a certificate to the database. There are two different ways to
call it, depending on whether you have a self-signed certificate
or not. With a self-signed certificate, the --realm and --issuer options
are left out, with a "normal" certificate, they are mandatory.

The command outputs the subject's DN and the issuer's DN for you to
verify that you imported the correct certificate as well as a unique
identifier which can be used to globally reference the certificate
(i.e. for configuration or as an issuer). If you don't want to remember
the identifier, look into openxpkiadm certificate alias to find out
how to create a symbolic name for an identifier.

Examples:

  openxpkiadm certificate import --file cacert.pem

Imports a self-signed CA certificate.

  openxpkiadm certificate import --realm 'Root CA' \
        --file subca1.pem --issuer 'Root CA 1'

Imports a Sub CA certificate which is signed by Root CA 1.

=item B<remove>

Subcommand options:

Mandatory:
  --name            The alias or identifier of the certificate

Optional:
  --realm           The PKI realm in which the alias is defined

Force options (use only if you now what you are doing!):
  --force-is-issuer Delete certificate even though it is the
                    issuer of another certificate in the database

Removes a certificate from the database.

Example:

  openxpkiadm certificate remove --realm 'Root CA' \
        --name 'Root CA 1'

=item B<chain>

Subcommand options:

 Mandatory:
  --realm               The PKI realm to operate in
  --name                The alias or identifier of the child
  --issuer              The alias or identifier of the parent

Optional:
  --issuer-realm        The realm in which the issuer alias
                        is defined

Force options (use only if you now what you are doing!):
  --force-certificate-not-found
        Ignore that the certificate of the child was not found
        in the DB
  --force-issuer-certificate-not-found
        Ignore that the certificate of the parent was not found
        in the DB

Once again, only use these options if you actually have to (the
occasions where this happens should be really, really rare).

Specifies subject/issuer relationship in order to set up certificate
chains. The certificates to be connected must already be present in
the database (see B<import>). As those connections are already set up
during --import, this command exists for changing the issuer if you
made an error. It also allows to specify an issuer that does not
agree with the information contained in the certificate (but outputs
a warning)

 Example:

openxpkiadm certificate chain --realm 'Root CA' \
     --name 'Subordinate CA 1' --issuer 'root1'

=back

=head2 alias

An alias is a symbolic name for a certificate in a specific realm.
OpenXPKI uses aliases to manage the crypto tokens for signer and
helper tokens. Several configs options and commands are able to
process aliases, too.

The selection of functional tokens is done based on the notbefore/notafter
date. To force certain behaviour (e.g time of a ca rollover), you can force
a custom notbefore/notafter date on the aliases.

Common options:
    --realm        PKI realm for the alias
    --identifier   The identifier of the certificate
    --notbefore    custom notbefore date to set
    --notafter     custom notafter date to set
                   accepted formats are epoch or yyyy-mm-dd hh:mm:ss
                   a literal 0 restores the certificates validity.

There are different ways to deal with aliases:

=over

=item B<list active functional tokens>

If you pass a realm but no identifier, you will receive the list of
active tokens for the functional token groups, the current root certificate
and, if set, the upcoming root certificate as used by scep I<GetNexCACert>.

For items with custom notbefore/notafter settings, the certificate's value
is shown in brackets:

    upcoming root ca:
        Alias     : root-2
        Identifier: xGBSVo6N-9gpjB8UFll4TS-u-Eo
        NotBefore : 2014-01-01 00:00:00 (2013-06-17 13:54:34)
        NotAfter  : 2016-12-31 23:59:59 (2020-06-17 13:54:34)


=item B<add functional token with automatic group discovery>

Looks up the name of the associated group and finds the next generation
index by looking up the present aliases in the group. Recommended.

  --token  The name of the token type you want to add,
           e.g. certsign or datasafe.

Example:

    openxpkiadm alias --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \
        --token certsign

=item B<add functional token with manual group configuration>

The alias for is automatically set to <group>-<generation>, e.g. server-ca-1.

  --group           The name of the group (e.g. server-ca)
  --generation      The numeric index to use for this alias

Example:

    openxpkiadm alias --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \
        --group server-ca --gen 1

=item B<add non-functional alias>

Adds the alias leaving group and generation empty.

  --alias               The symbolic name for the certificate

Example:

    openxpkiadm alias --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \
        --alias my-very-important-certificate

=item B<update alias>

Update notebefore/notafter date of an existing alias.

    --update        Indicates that you want to update anm existing entry
    --alias         You can select the alias by name rather than passing
                    the identifier.

Example:

     openxpkiadm alias --update --realm ca-one \
         --alias ca-one-signer-1
         --notbefore "2014-01-01:00:00:00"

This updates notbefore, notafter is not changed.

=item B<remove alias>

Remove the entry from the alias table.

  --remove          Indicates that the alias should be removed.
  --alias           You can select the alias by name rather than passing
                    the identifier.

Example:

    openxpkiadm alias --remove --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \

    openxpkiadm alias --remove --realm server-realm \
        --alias server-ca-1

=back

=head2 loadcfg

Load the YaML config into the internal git repository.

Command options:

  --path DIR    Path to the YaML files
  --dbpath DIR  Path to the internal repository
  --reload      Signal the running server to immediately use the new config.

Read the files found at the config directory given by I<path> (defaults to
/etc/openxpki/config.d) and load them into the internal config repository at
the directory given by I<dbpath> (default /etc/openxpki/config.git).
If I<reload> is given and the openxpki daemon is running, the daemon is send
a reload signal and will start using the new configuration for new requests.
Note: Even if I<reload> is not passed, the config becomes active on the next
server start! Some changes need a restart to become active, see the documentation!

=head2 hashpwd

Create the hash of a given password to be used with the internal user database.

Command options:

  --scheme   The hashing scheme to use, allowed values are
             ssha|sha|smd5|md5|crypt, default is ssha
             see also OpenXPKI::Server::Authentication::Password

Prompts for the password and prints the hashed value including the used
 scheme as defined in RFC2307.

=head1 DESCRIPTION

B<openxpkiadm> is the administrative frontend for controlling the OpenXPKI
installation.

=over 8

The openxpkiadm script returns a 0 exit value on success, and >0 if  an
error occurs.

=back







